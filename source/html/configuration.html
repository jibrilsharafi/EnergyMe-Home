<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="/css/button.css">
    <link rel="stylesheet" type="text/css" href="/css/styles.css">
    <link rel="stylesheet" type="text/css" href="/css/section.css">
    <link rel="stylesheet" type="text/css" href="/css/typography.css">

    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <title>Configuration</title>
    <style>
        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 15px;
            border-radius: 5px;
            background: linear-gradient(to right, var(--green) 0%, var(--green) calc(var(--slider-value, 50%) - 1.25%), #d3d3d3 calc(var(--slider-value, 50%) + 1.25%), #d3d3d3 100%);
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: var(--green);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: var(--green);
            cursor: pointer;
        }
        
        /* Mobile responsive form styles */
        @media screen and (max-width: 768px) {
            .config-input {
                width: 100% !important;
                max-width: 100% !important;
                font-size: 16px !important; /* Prevents zoom on iOS */
                padding: 12px !important;
                margin: 8px 0 !important;
                box-sizing: border-box !important;
                border: 1px solid #ddd !important;
                border-radius: 5px !important;
            }
            
            label {
                display: block;
                font-weight: bold;
                margin-bottom: 5px;
                font-size: 14px;
            }
            
            select.config-input {
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
                background-position: right 12px center;
                background-repeat: no-repeat;
                background-size: 16px;
                padding-right: 40px;
            }
            
            .warning-box {
                padding: 8px !important;
                font-size: 13px !important;
                margin: 8px 0 !important;
            }
            
            .slider {
                height: 20px !important;
                margin: 10px 0 !important;
            }
            
            .slider::-webkit-slider-thumb {
                width: 30px;
                height: 30px;
            }
            
            .slider::-moz-range-thumb {
                width: 30px;
                height: 30px;
            }
            
            #influxDbStatusContainer {
                flex-direction: column !important;
                align-items: flex-start !important;
            }
            
            #influxDbStatusIcon {
                margin-bottom: 8px !important;
                margin-right: 0 !important;
            }
            
            #energyChannels .channel-container {
                margin-bottom: 15px;
                padding: 10px;
                border: 1px solid #eee;
                border-radius: 5px;
                background-color: #f9f9f9;
            }
            
            table {
                width: 100% !important;
                font-size: 13px !important;
                overflow-x: auto !important;
                display: block !important;
            }
            
            table thead,
            table tbody,
            table tr {
                display: block !important;
            }
            
            table td,
            table th {
                display: block !important;
                width: 100% !important;
                padding: 8px 5px !important;
                border: none !important;
                text-align: left !important;
            }
            
            table th {
                background-color: #f5f5f5 !important;
                font-weight: bold !important;
            }
            
            table tr {
                border-bottom: 1px solid #ddd !important;
                margin-bottom: 10px !important;
            }
        }
        
        @media screen and (max-width: 480px) {
            .config-input {
                font-size: 14px !important;
                padding: 10px !important;
            }
            
            label {
                font-size: 13px;
            }
            
            .warning-box {
                font-size: 12px !important;
            }
        }
    </style>
</head>

<body>
    <div class="buttonNavigation-container">
        <a class="buttonNavigation" type="home" href="/">üè† Home</a>
        <a class="buttonNavigation" type="inner" href="/calibration">‚öñÔ∏è Calibration</a>
        <a class="buttonNavigation" type="inner" href="/channel">üì∫ Channel</a>
    </div>

    <div class="section-box">
        <h2>Cloud Services</h2>
        <p><i>Cloud services are used to send data to the cloud. This is useful for monitoring the device
                remotely and get the latest firmware updates.</i></p>
        <input type="checkbox" id="cloudServices" class="config-input">
        <label for="cloudServices">Enable cloud services</label>
        <br><br>
        <button class="buttonForm" onclick="setCloudServices()" id="setCloudServicesButton">‚òÅÔ∏è Set cloud services</button>
    </div>

    <div class="section-box">
        <h2>LED Brightness</h2>
        <p><i>LED brightness is used to adjust the brightness of the status LED on the device. Keeping a small
                amount of brightness is recommended.</i></p>
        <input type="range" id="ledBrightness" class="config-input slider" min="0" max="100"
            oninput="updateBrightnessValue()">
        <span id="ledBrightnessValue">50%</span>
        <br><br>
        <button class="buttonForm" onclick="setLedBrightness()" id="setLedBrightnessButton">üí° Set brightness</button>
    </div>

    <div class="section-box">
        <h2>Logging</h2>
        <p><i>Logging is used to record events and errors. It is useful for debugging and troubleshooting.</i></p>
        <div>
            <h3>Print</h3>
            <p><i>Print logging is used to display events and errors when the serial monitor is available. The serial
                    monitor is available when the device is connected to a computer via USB.</i></p>
            <select id="printLogLevel" class="config-input"></select>
        </div>
        <br>
        <div>
            <h3>Save</h3>
            <p><i>Save logging is used to record events and errors to the internal memory of the device. The internal
                    memory is limited, so it is recommended to only use this for troubleshooting.</i></p>
            <select id="saveLogLevel" class="config-input"></select>
        </div>
        <br>
        <button class="buttonForm" onclick="setLogLevel()" id="setLogLevel">üìù Set logging level</button>
        <button class="buttonForm" onclick="clearLogs()" id="clearLogs">üóëÔ∏è Clear log</button>
        <a class="buttonForm" href="/log" id="log" style="float: right;">üìã Explore log</a>
    </div>

    <div class="section-box">
        <h2>Custom MQTT</h2>
        <p><i>
                Custom MQTT is used to send meter data to a custom MQTT server. This is useful for integrating the
                device with your own IoT platform.
                <br>
                <br>
                The payload content will be the same one returned by the REST API endpoint <a href="/api/v1/ade7953/meter-values"
                    target="_blank">meter</a>
                (<a href="/swagger-ui#/ADE7953/get_api_v1_ade7953_meter_values" target="_blank">swagger</a>).
            </i></p>
        <input type="checkbox" id="customMqttEnabled" class="config-input">
        <label for="customMqttEnabled">Enable custom MQTT</label>
        <div id="customMqttSettings">
            <label for="customMqttServer">Server:</label>
            <input type="text" id="customMqttServer" class="config-input" placeholder="e.g., mqtt.example.com">
            <br>
            <label for="customMqttPort">Port:</label>
            <input type="number" id="customMqttPort" class="config-input" placeholder="e.g., 1883">
            <br>
            <label for="customMqttClientId">Client ID:</label>
            <input type="text" id="customMqttClientId" class="config-input" placeholder="e.g., client123">
            <br>
            <label for="customMqttTopic">Topic:</label>
            <input type="text" id="customMqttTopic" class="config-input" placeholder="e.g., home/sensor">
            <br>
            <label for="customMqttFrequency">Frequency (in seconds):</label>
            <input type="number" id="customMqttFrequency" class="config-input" placeholder="e.g., 60" min="1"
                max="86400">
            <br>
            <input type="checkbox" id="customMqttUseCredentials" class="config-input">
            <label for="useCredentials">Use credentials</label>
            <br>
            <label for="customMqttUsername">Username:</label>
            <input type="text" id="customMqttUsername" class="config-input" placeholder="Leave empty if not required">
            <br>
            <label for="customMqttPassword">Password:</label>
            <input type="password" id="customMqttPassword" class="config-input"
                placeholder="Leave empty if not required">
        </div>
        <div id="customMqttStatus"
            style="margin-top: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
            <div id="statusContainer" style="display: flex; align-items: center;">
                <span id="statusIcon" style="font-size: 1.5em; margin-right: 10px;">‚ö™</span>
                <div>
                    <strong>Status: </strong><span id="lastConnectionStatus">Loading...</span><br>
                    <span id="timestampContainer"><strong>Last Attempt: </strong><span
                            id="lastConnectionAttemptTimestamp">Loading...</span></span>
                </div>
            </div>
        </div> <button class="buttonForm" onclick="setCustomMqttConfiguration()"
            id="setCustomMqttConfigurationButton">üíæ Set
            configuration</button>
        <button class="buttonForm" onclick="getCustomMqttConfiguration()" id="reloadCustomMqttButton"
            style="float: right;">üîÑ Reload Status</button>
    </div>

    <div class="section-box">
        <h2>InfluxDB</h2>
        <p><i>
                InfluxDB is used to send meter data to an InfluxDB time-series database. This is useful for storing
                historical data and creating dashboards with tools like Grafana.
                <br>
                <br>
                The data will be sent in InfluxDB Line Protocol format with all meter values as fields.
            </i></p>
        <input type="checkbox" id="influxDbEnabled" class="config-input">
        <label for="influxDbEnabled">Enable InfluxDB</label>
        <div id="influxDbSettings">
            <label for="influxDbServer">Server:</label>
            <input type="text" id="influxDbServer" class="config-input"
                placeholder="e.g., localhost or influxdb.example.com">
            <br>
            <label for="influxDbPort">Port:</label>
            <input type="number" id="influxDbPort" class="config-input" placeholder="e.g., 8086">
            <br>
            <label for="influxDbVersion">Version:</label>
            <select id="influxDbVersion" class="config-input">
                <option value="1">InfluxDB v1.x</option>
                <option value="2">InfluxDB v2.x</option>
            </select>
            <br>
            <input type="checkbox" id="influxDbUseSsl" class="config-input">
            <label for="influxDbUseSsl">Use SSL (HTTPS)</label>
            <br>
            <div id="influxDbV1Settings">
                <h4>InfluxDB v1.x Settings</h4>
                <label for="influxDbDatabase">Database:</label>
                <input type="text" id="influxDbDatabase" class="config-input" placeholder="e.g., energyme-home">
                <br>
                <label for="influxDbUsername">Username:</label>
                <input type="text" id="influxDbUsername" class="config-input" placeholder="Leave empty if not required">
                <br>
                <label for="influxDbPassword">Password:</label>
                <input type="password" id="influxDbPassword" class="config-input"
                    placeholder="Leave empty if not required">
            </div>
            <div id="influxDbV2Settings">
                <h4>InfluxDB v2.x Settings</h4>
                <label for="influxDbOrganization">Organization:</label>
                <input type="text" id="influxDbOrganization" class="config-input" placeholder="e.g., my-org">
                <br>
                <label for="influxDbBucket">Bucket:</label>
                <input type="text" id="influxDbBucket" class="config-input" placeholder="e.g., energyme-home">
                <br>
                <label for="influxDbToken">Token:</label>
                <input type="password" id="influxDbToken" class="config-input" placeholder="API token">
            </div>
            <label for="influxDbMeasurement">Measurement:</label>
            <input type="text" id="influxDbMeasurement" class="config-input" placeholder="e.g., meter">
            <br>
            <label for="influxDbFrequency">Frequency (in seconds):</label>
            <input type="number" id="influxDbFrequency" class="config-input" placeholder="e.g., 30" min="1" max="3600">
        </div>
        <div id="influxDbStatus"
            style="margin-top: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
            <div id="influxDbStatusContainer" style="display: flex; align-items: center;">
                <span id="influxDbStatusIcon" style="font-size: 1.5em; margin-right: 10px;">‚ö™</span>
                <div>
                    <strong>Status: </strong><span id="influxDbLastConnectionStatus">Loading...</span><br>
                    <span id="influxDbTimestampContainer"><strong>Last Attempt: </strong><span
                            id="influxDbLastConnectionAttemptTimestamp">Loading...</span></span>
                </div>
            </div>
        </div> <button class="buttonForm" onclick="setInfluxDbConfiguration()" id="setInfluxDbConfigurationButton">üíæ
            Set
            configuration</button>
        <button class="buttonForm" onclick="getInfluxDbConfiguration()" id="reloadInfluxDbButton"
            style="float: right;">üîÑ Reload Status</button>
    </div>

    <div class="section-box">
        <h2>Energy Management</h2>
        <p><i>Manage energy counters for all channels. Changes will clear historical daily energy data.</i></p>

        <div id="energyChannels">
            <!-- Energy channels will be populated here -->
        </div> <button class="buttonForm" onclick="loadEnergyValues()" id="loadEnergyButton">üîÑ Load Current
            Values</button>
        <button class="buttonForm" onclick="setEnergyValues()" id="setEnergyButton">üíæ Set Energy Values</button>
        <button class="buttonForm" onclick="resetAllEnergy()" id="resetAllEnergyButton"
            style="background-color: #dc3545; border-color: #dc3545; color: white; transition: background-color 0.3s ease;"
            onmouseover="this.style.backgroundColor='#c82333'" onmouseout="this.style.backgroundColor='#dc3545'">üóëÔ∏è
            Reset
            All to Zero</button>
    </div>

    <div class="section-box">
        <h2>Restart Device</h2>
        <p><i>You already know that restarting a device magically fixes most issues. It will take 10 seconds.</i></p>
        <button class="buttonForm" onclick="restart()" id="restart">üîÑ Restart</button>
    </div>

    <div class="section-box">
        <h2>Disconnect from WiFi</h2>
        <p><i>This will erase the WiFi credentials.</i></p>
        <p><i>The device will create a WiFi network called "EnergyMe" with no password.
                Connect to that network and navigate to <a href="http://192.168.4.1" ,
                    target="_blank">http://192.168.4.1</a>
                (or <a href="http://energyme.local" , target="_blank">http://energyme.local</a>)
                if the device does not redirect you automatically.
                You can then configure the device to connect to your WiFi network.</i></p>
        <div class="warning-box"
            style="background-color: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; margin: 10px 0;"> ‚ö†Ô∏è
            Warning: You will lose access to the device until you reconnect it to WiFi.
        </div>
        <button class="buttonForm" onclick="disconnectWifi()" id="disconnect">üì∂ Disconnect</button>
    </div>

    <div class="section-box">
        <h2>Factory Reset</h2>
        <p><i>This will reset the device to its factory settings. Useful if you are having issues with the device or
                want to start fresh.</i></p>
        <p><i>WiFi credentials will be kept.</i></p>
        <div class="warning-box"
            style="background-color: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; margin: 10px 0;"> ‚ö†Ô∏è
            Warning: This will erase all configurations and data. This action cannot be undone.
        </div>
        <button class="buttonForm" onclick="factoryReset()" id="factoryReset">üè≠ Reset</button>
    </div>

    <script src="/js/api-client.js"></script>
    <script>
        var logLevels = ["Verbose", "Debug", "Info", "Warning", "Error", "Fatal"];
        var customMqttConfig;
        var influxDbConfig;
        var energyData = {};
        var channelData = {};

        // Auto-reload intervals
        var customMqttAutoReloadInterval = null;
        var influxDbAutoReloadInterval = null;
        const AUTO_RELOAD_INTERVAL_MS = 5000; // 5 seconds

        function populateDropdown() {
            var printLogLevel = document.getElementById("printLogLevel");
            var saveLogLevel = document.getElementById("saveLogLevel");

            // Clear existing options
            printLogLevel.innerHTML = "";
            saveLogLevel.innerHTML = "";

            for (var i = 0; i < logLevels.length; i++) {
            var opt = document.createElement("option");
            opt.value = logLevels[i];
            opt.innerHTML = logLevels[i];

            printLogLevel.appendChild(opt.cloneNode(true));
            // Exclude "Verbose" from saveLogLevel
            if (logLevels[i] !== "Verbose") {
                saveLogLevel.appendChild(opt.cloneNode(true));
            }
            }
        }

        function restart() {
            var restartButton = document.getElementById("restart");
            restartButton.innerHTML = "Restarting. You will be redirected to the home page in some seconds.";
            restartButton.disabled = true;

            energyApi.restartSystem()
                .then(response => {
                    setTimeout(function () {
                        window.location.href = "/";
                    }, 12000);
                })
                .catch(error => {
                    alert("Error restarting device. Response: " + error.message);
                    restartButton.innerHTML = "üîÑ Restart";
                    restartButton.disabled = false;
                });
        } 
        
        function disconnectWifi() {
            var confirm = window.confirm("Are you sure you want to disconnect from WiFi? You will lose access to the device until you reconnect it to WiFi.");
            if (!confirm) {
                return;
            }
            document.getElementById("disconnect").innerHTML = "Disconnecting...";
            document.getElementById("disconnect").disabled = true;

            energyApi.resetWifi()
                .then(response => {
                    alert("Successfully disconnected from WiFi. Please connect to the WiFi network called 'EnergyMe' and navigate to http://192.168.4.1");
                })
                .catch(error => {
                    alert("Error disconnecting from WiFi. Response: " + error.message);
                });
        } 
        
        function factoryReset() {
            var confirm = window.confirm("Are you sure you want to reset the device to factory settings? All configurations and data will be lost.");
            if (!confirm) {
                return;
            }
            document.getElementById("factoryReset").innerHTML = "Waiting for response...";
            document.getElementById("factoryReset").disabled = true;

            energyApi.factoryReset()
                .then(response => {
                    document.getElementById("factoryReset").innerHTML = "Reset successful! You will be redirected to the home page in 15 seconds.";
                    setTimeout(function () {
                        window.location.href = "/";
                    }, 15000);
                })
                .catch(error => {
                    alert("Error resetting to factory settings. Response: " + error.message);
                });
        } 
        
        function setLogLevel() {
            document.getElementById("setLogLevel").innerHTML = "Setting...";
            document.getElementById("setLogLevel").disabled = true;

            var printLogLevel = document.getElementById("printLogLevel").value.toUpperCase();
            var saveLogLevel = document.getElementById("saveLogLevel").value.toUpperCase();

            // API expects string values like "VERBOSE", "DEBUG", etc.
            var validLevels = ["VERBOSE", "DEBUG", "INFO", "WARNING", "ERROR", "FATAL"];

            // Validate that the levels are valid
            if (!validLevels.includes(printLogLevel) || !validLevels.includes(saveLogLevel)) {
                alert("Invalid log level selected");
                document.getElementById("setLogLevel").innerHTML = "üìù Set logging level";
                document.getElementById("setLogLevel").disabled = false;
                return;
            }

            console.log("Setting log levels:", { print: printLogLevel, save: saveLogLevel });

            energyApi.setLogLevels({
                print: printLogLevel,
                save: saveLogLevel
            })
                .then(response => {
                    document.getElementById("setLogLevel").innerHTML = "Set success!";
                    setTimeout(function () {
                        document.getElementById("setLogLevel").innerHTML = "üìù Set logging level";
                        document.getElementById("setLogLevel").disabled = false;
                    }, 3000);
                })
                .catch(error => {
                    alert("Error setting log level. Response: " + error.message);
                    document.getElementById("setLogLevel").innerHTML = "Set failed!";
                    setTimeout(function () {
                        document.getElementById("setLogLevel").innerHTML = "üìù Set logging level";
                        document.getElementById("setLogLevel").disabled = false;
                    }, 3000);
                });
        }
        
        function getLogLevel() {
            energyApi.getLogLevels()
                .then(data => {
                    // API returns string values like "VERBOSE", "DEBUG", etc.
                    // Convert to dropdown format (first letter uppercase, rest lowercase)
                    function formatLevelForDropdown(level) {
                        if (!level) return "Debug";
                        return level.charAt(0).toUpperCase() + level.slice(1).toLowerCase();
                    }
                    
                    var printLogLevel = formatLevelForDropdown(data.print);
                    var saveLogLevel = formatLevelForDropdown(data.save);

                    populateDropdown();
                    document.getElementById("printLogLevel").value = printLogLevel;
                    document.getElementById("saveLogLevel").value = saveLogLevel;
                })
                .catch(error => {
                    console.log("Error getting log levels. Response: " + error.message);
                });
        } 
        
        function clearLogs() {
            var confirm = window.confirm("Are you sure you want to clear the log?");
            if (!confirm) {
                return;
            }
            document.getElementById("clearLogs").innerHTML = "Clearing...";
            document.getElementById("clearLogs").disabled = true;

            energyApi.clearLogs()
                .then(response => {
                    document.getElementById("clearLogs").innerHTML = "Clear success";
                    setTimeout(function () {
                        document.getElementById("clearLogs").innerHTML = "üóëÔ∏è Clear log";
                        document.getElementById("clearLogs").disabled = false;
                    }, 3000);
                })
                .catch(error => {
                    alert("Error clearing log. Response: " + error.message);
                    setTimeout(function () {
                        document.getElementById("clearLogs").innerHTML = "üóëÔ∏è Clear log";
                        document.getElementById("clearLogs").disabled = false;
                    }, 3000);
                });
        }

        function getCloudServices() {
            energyApi.getMqttCloudServices()
                .then(data => {
                    document.getElementById("cloudServices").checked = data.enabled;
                })
                .catch(error => {
                    console.log("Error getting cloud services status. Response: " + error.message);
                });
        }

        function setCloudServices() {
            document.getElementById("setCloudServicesButton").innerHTML = "Setting...";
            document.getElementById("setCloudServicesButton").disabled = true;

            // First check secrets status
            energyApi.getSystemSecrets()
                .then(secretsResponse => {
                    const isEnabled = document.getElementById("cloudServices").checked;
                    
                    // If no secrets but cloud services is checked, prevent that
                    if (!secretsResponse.hasSecrets && isEnabled) {
                        alert("Cannot enable cloud services: This firmware build does not include secrets.");
                        document.getElementById("cloudServices").checked = false;
                        throw new Error("No secrets available");
                    }

                    // Send the configuration
                    return energyApi.setMqttCloudServices(isEnabled);
                })
                .then(data => {
                    document.getElementById("setCloudServicesButton").innerHTML = "Set success!";
                    setTimeout(function () {
                        document.getElementById("setCloudServicesButton").innerHTML = "‚òÅÔ∏è Set cloud services";
                        document.getElementById("setCloudServicesButton").disabled = false;
                    }, 3000);
                })
                .catch(error => {
                    if (error.message !== "No secrets available") {
                        alert("Error setting cloud services. Response: " + error.message);
                    }
                    document.getElementById("setCloudServicesButton").innerHTML = "Set failed!";
                    setTimeout(function () {
                        document.getElementById("setCloudServicesButton").innerHTML = "‚òÅÔ∏è Set cloud services";
                        document.getElementById("setCloudServicesButton").disabled = false;
                    }, 3000);
                });
        }

        function getLedBrightness() {
            energyApi.getLedBrightness()
                .then(data => {
                    // Assuming API returns brightness as 0-100 range
                    document.getElementById("ledBrightness").value = data.brightness;
                    updateBrightnessValue();
                })
                .catch(error => {
                    console.log("Error getting LED brightness. Response: " + error.message);
                });
        }

        function setLedBrightness() {
            document.getElementById("setLedBrightnessButton").innerHTML = "Setting...";
            document.getElementById("setLedBrightnessButton").disabled = true;

            const brightness = parseInt(document.getElementById("ledBrightness").value);

            energyApi.setLedBrightness(brightness)
                .then(data => {
                    document.getElementById("setLedBrightnessButton").innerHTML = "Set success!";
                    setTimeout(function () {
                        document.getElementById("setLedBrightnessButton").innerHTML = "üí° Set brightness";
                        document.getElementById("setLedBrightnessButton").disabled = false;
                    }, 3000);
                })
                .catch(error => {
                    alert("Error setting LED brightness. Response: " + error.message);
                    document.getElementById("setLedBrightnessButton").innerHTML = "Set failed!";
                    setTimeout(function () {
                        document.getElementById("setLedBrightnessButton").innerHTML = "üí° Set brightness";
                        document.getElementById("setLedBrightnessButton").disabled = false;
                    }, 3000);
                });
        }

        function updateBrightnessValue() {
            var slider = document.getElementById("ledBrightness");
            var output = document.getElementById("ledBrightnessValue");
            var percentage = parseInt(slider.value);
            slider.style.setProperty('--slider-value', percentage + '%');
            slider.title = percentage + "%";
            output.innerHTML = percentage + "%";
        }

        function getCustomMqttConfiguration() {
            // Load configuration
            energyApi.getCustomMqttConfig()
                .then(data => {
                    customMqttConfig = data;

                    document.getElementById("customMqttEnabled").checked = customMqttConfig.enabled;
                    document.getElementById("customMqttServer").value = customMqttConfig.server;
                    document.getElementById("customMqttPort").value = customMqttConfig.port;
                    document.getElementById("customMqttClientId").value = customMqttConfig.clientid;
                    document.getElementById("customMqttTopic").value = customMqttConfig.topic;
                    document.getElementById("customMqttFrequency").value = customMqttConfig.frequency;
                    document.getElementById("customMqttUseCredentials").checked = customMqttConfig.useCredentials;
                    document.getElementById("customMqttUsername").value = customMqttConfig.username;
                    document.getElementById("customMqttPassword").value = customMqttConfig.password;

                    // Load status separately
                    loadCustomMqttStatus();

                    // Start or stop auto-reload based on enabled status
                    if (customMqttConfig.enabled) {
                        startCustomMqttAutoReload();
                    } else {
                        stopCustomMqttAutoReload();
                    }
                })
                .catch(error => {
                    console.log("Error getting custom MQTT configuration. Response: " + error.message);
                    updateStatusDisplay("Error loading configuration", "", false);
                    stopCustomMqttAutoReload();
                });
        }

        function loadCustomMqttStatus() {
            energyApi.get('custom-mqtt/status')
                .then(data => {
                    // Update status display with the latest status information
                    updateStatusDisplay(data.status, data.statusTimestamp, customMqttConfig.enabled);
                })
                .catch(error => {
                    console.log("Error getting custom MQTT status. Response: " + error.message);
                    updateStatusDisplay("Error loading status", "", false);
                });
        }

        function startCustomMqttAutoReload() {
            if (customMqttAutoReloadInterval) {
                clearInterval(customMqttAutoReloadInterval);
            }
            customMqttAutoReloadInterval = setInterval(() => {
                if (customMqttConfig && customMqttConfig.enabled) {
                    loadCustomMqttStatus();
                }
            }, AUTO_RELOAD_INTERVAL_MS);
        }

        function stopCustomMqttAutoReload() {
            if (customMqttAutoReloadInterval) {
                clearInterval(customMqttAutoReloadInterval);
                customMqttAutoReloadInterval = null;
            }
        }

        function updateStatusDisplay(status, timestamp, isEnabled) {
            const statusElement = document.getElementById("lastConnectionStatus");
            const timestampElement = document.getElementById("lastConnectionAttemptTimestamp");
            const timestampContainer = document.getElementById("timestampContainer");
            const statusIcon = document.getElementById("statusIcon");
            const statusContainer = document.getElementById("statusContainer");

            // Reset styles
            statusContainer.style.color = "";
            statusElement.style.fontWeight = "";

            // If MQTT is disabled, show disabled status
            if (!isEnabled) {
                statusElement.textContent = "Disabled";
                timestampContainer.style.display = "none";
                statusIcon.innerHTML = "‚ö´"; // Black circle for disabled
                statusElement.style.color = "#757575"; // Gray color
                return;
            }

            // If enabled, proceed with normal status display
            statusElement.textContent = status || "N/A";
            timestampElement.textContent = timestamp || "N/A";

            // Show/hide timestamp based on connection status
            if (status === "Connected") {
                timestampContainer.style.display = "none";
                statusIcon.innerHTML = "üü¢"; // Green circle for connected
                statusElement.style.color = "#2e7d32"; // Dark green
                statusElement.style.fontWeight = "bold";
            } else if (status === "Disconnected") {
                timestampContainer.style.display = "block";
                statusIcon.innerHTML = "üî¥"; // Red circle for disconnected
                statusElement.style.color = "#c62828"; // Dark red
            } else if (status && status.startsWith("Error")) {
                timestampContainer.style.display = "block";
                statusIcon.innerHTML = "‚ö†Ô∏è"; // Warning for errors
                statusElement.style.color = "#e65100"; // Orange
            } else {
                timestampContainer.style.display = "block";
                statusIcon.innerHTML = "‚ö™"; // Default neutral circle
            }
        }

        function setCustomMqttConfiguration() {
            document.getElementById("setCustomMqttConfigurationButton").innerHTML = "Setting...";
            document.getElementById("setCustomMqttConfigurationButton").disabled = true;

            var currentStatus = customMqttConfig ? customMqttConfig.lastConnectionStatus : "Unknown";
            var currentTimestamp = customMqttConfig ? customMqttConfig.lastConnectionAttemptTimestamp : "";

            var newCustomMqttConfig = {
                "enabled": document.getElementById("customMqttEnabled").checked,
                "server": document.getElementById("customMqttServer").value,
                "port": parseInt(document.getElementById("customMqttPort").value),
                "clientid": document.getElementById("customMqttClientId").value,
                "topic": document.getElementById("customMqttTopic").value,
                "frequency": parseInt(document.getElementById("customMqttFrequency").value),
                "useCredentials": document.getElementById("customMqttUseCredentials").checked,
                "username": document.getElementById("customMqttUsername").value,
                "password": document.getElementById("customMqttPassword").value,
                "lastConnectionStatus": currentStatus,
                "lastConnectionAttemptTimestamp": currentTimestamp
            };

            energyApi.setCustomMqttConfig(newCustomMqttConfig)
                .then(data => {
                    document.getElementById("setCustomMqttConfigurationButton").innerHTML = "Set success!";
                    setTimeout(() => {
                        getCustomMqttConfiguration(); // This will reload config and restart auto-reload if needed
                    }, 2000); // Wait 2 seconds for the device to process the new config
                    setTimeout(function () {
                        document.getElementById("setCustomMqttConfigurationButton").innerHTML = "Set configuration";
                        document.getElementById("setCustomMqttConfigurationButton").disabled = false;
                    }, 3000);
                })
                .catch(error => {
                    alert("Error setting custom MQTT configuration. Response: " + error.message);
                    document.getElementById("setCustomMqttConfigurationButton").innerHTML = "Set failed!";
                    setTimeout(function () {
                        document.getElementById("setCustomMqttConfigurationButton").innerHTML = "Set configuration";
                        document.getElementById("setCustomMqttConfigurationButton").disabled = false;
                    }, 3000);
                });

            // Call to refresh the custom MQTT configuration after setting it
            setTimeout(getCustomMqttConfiguration, 1000);
        }

        function checkHasSecrets() {
            energyApi.getSystemSecrets()
                .then(response => {
                    // If no secrets available, disable cloud services option
                    if (!response.hasSecrets) {
                        var cloudServicesCheckbox = document.getElementById("cloudServices");
                        cloudServicesCheckbox.disabled = true;
                        cloudServicesCheckbox.checked = false;

                        // Create warning message if it doesn't exist
                        if (!document.getElementById("cloud-services-warning")) {
                            var warningDiv = document.createElement("div");
                            warningDiv.id = "cloud-services-warning";
                            warningDiv.className = "warning-box";
                            warningDiv.style.backgroundColor = "#fff3cd";
                            warningDiv.style.color = "#856404";
                            warningDiv.style.padding = "10px";
                            warningDiv.style.borderRadius = "5px";
                            warningDiv.style.marginTop = "10px";
                            warningDiv.innerHTML = "‚ö†Ô∏è Cloud services require secrets to be included in the firmware. This build doesn't include secrets.";

                            // Insert after the cloud services label
                            var labelElement = document.querySelector("label[for='cloudServices']");
                            labelElement.parentNode.insertBefore(warningDiv, labelElement.nextSibling);
                        }
                    }
                })
                .catch(error => {
                    console.log("Error checking secrets status:", error.message);
                });
        }

        function updateInfluxDbStatusDisplay(status, timestamp, isEnabled) {
            const statusElement = document.getElementById("influxDbLastConnectionStatus");
            const timestampElement = document.getElementById("influxDbLastConnectionAttemptTimestamp");
            const timestampContainer = document.getElementById("influxDbTimestampContainer");
            const statusIcon = document.getElementById("influxDbStatusIcon");
            const statusContainer = document.getElementById("influxDbStatusContainer");

            // Reset styles
            statusContainer.style.color = "";
            statusElement.style.fontWeight = "";

            // TODO:
            // When setting a configuration with invalid credentials, the result will be like this in the running status:

            // {
            // "status": "Disabled due to persistent failures",
            // "statusTimestamp": "2025-08-14T10:32:19.000Z"
            // }

            // Now we just show disabled since the enabled key in the configuration is not true. How can we easily show the latest status in these cases? Maybe something time based? Or some better alternatives?
            
            // If InfluxDB is disabled, show disabled status
            if (!isEnabled) {
                statusElement.textContent = "Disabled";
                timestampContainer.style.display = "none";
                statusIcon.innerHTML = "‚ö´"; // Black circle for disabled
                statusElement.style.color = "#757575"; // Gray color
                return;
            }

            // If enabled, proceed with normal status display
            statusElement.textContent = status || "N/A";
            timestampElement.textContent = timestamp || "N/A";

            // Show/hide timestamp based on connection status
            if (status === "Upload successful" || status === "Connection successful" || status === "Credentials valid" || status == "Data sent successfully") {
                timestampContainer.style.display = "none"; // Hide timestamp for successful connections
                statusIcon.innerHTML = "üü¢"; // Green circle for successful
                statusElement.style.color = "#2e7d32"; // Dark green
                statusElement.style.fontWeight = "bold";
            } else if (status && status.toLowerCase().includes("failed")) {
                timestampContainer.style.display = "block";
                statusIcon.innerHTML = "üî¥"; // Red circle for failed
                statusElement.style.color = "#c62828"; // Dark red
            } else if (status && status.includes("Error")) {
                timestampContainer.style.display = "block";
                statusIcon.innerHTML = "‚ö†Ô∏è"; // Warning for errors
                statusElement.style.color = "#e65100"; // Orange
            } else {
                timestampContainer.style.display = "block";
                statusIcon.innerHTML = "‚ö™"; // Default neutral circle
            }
        }

        function toggleInfluxDbVersionSettings() {
            const version = document.getElementById("influxDbVersion").value;
            const v1Settings = document.getElementById("influxDbV1Settings");
            const v2Settings = document.getElementById("influxDbV2Settings");

            if (version === "1") {
                v1Settings.style.display = "block";
                v2Settings.style.display = "none";
            } else {
                v1Settings.style.display = "none";
                v2Settings.style.display = "block";
            }
        }

        function getInfluxDbConfiguration() {
            energyApi.getInfluxDbConfig()
                .then(data => {
                    influxDbConfig = data;

                    document.getElementById("influxDbEnabled").checked = influxDbConfig.enabled;
                    document.getElementById("influxDbServer").value = influxDbConfig.server;
                    document.getElementById("influxDbPort").value = influxDbConfig.port;
                    document.getElementById("influxDbVersion").value = influxDbConfig.version;
                    document.getElementById("influxDbDatabase").value = influxDbConfig.database;
                    document.getElementById("influxDbUsername").value = influxDbConfig.username;
                    document.getElementById("influxDbPassword").value = influxDbConfig.password;
                    document.getElementById("influxDbOrganization").value = influxDbConfig.organization;
                    document.getElementById("influxDbBucket").value = influxDbConfig.bucket;
                    document.getElementById("influxDbToken").value = influxDbConfig.token;
                    document.getElementById("influxDbMeasurement").value = influxDbConfig.measurement;
                    document.getElementById("influxDbFrequency").value = influxDbConfig.frequency;
                    document.getElementById("influxDbUseSsl").checked = influxDbConfig.useSsl;

                    toggleInfluxDbVersionSettings();

                    // Load status separately
                    loadInfluxDbStatus();

                    // Start or stop auto-reload based on enabled status
                    if (influxDbConfig.enabled) {
                        startInfluxDbAutoReload();
                    } else {
                        stopInfluxDbAutoReload();
                    }
                })
                .catch(error => {
                    console.log("Error getting InfluxDB configuration. Response: " + error.message);
                    updateInfluxDbStatusDisplay("Error loading configuration", "", false);
                    stopInfluxDbAutoReload();
                });
        }

        function loadInfluxDbStatus() {
            energyApi.get('influxdb/status')
                .then(data => {
                    // Update status display with the latest status information
                    updateInfluxDbStatusDisplay(data.status, data.statusTimestamp, influxDbConfig.enabled);
                })
                .catch(error => {
                    console.log("Error getting InfluxDB status. Response: " + error.message);
                    updateInfluxDbStatusDisplay("Error loading status", "", false);
                });
        }

        function startInfluxDbAutoReload() {
            if (influxDbAutoReloadInterval) {
                clearInterval(influxDbAutoReloadInterval);
            }
            influxDbAutoReloadInterval = setInterval(() => {
                if (influxDbConfig && influxDbConfig.enabled) {
                    loadInfluxDbStatus();
                }
            }, AUTO_RELOAD_INTERVAL_MS);
        }

        function stopInfluxDbAutoReload() {
            if (influxDbAutoReloadInterval) {
                clearInterval(influxDbAutoReloadInterval);
                influxDbAutoReloadInterval = null;
            }
        }

        function setInfluxDbConfiguration() {
            document.getElementById("setInfluxDbConfigurationButton").innerHTML = "Setting...";
            document.getElementById("setInfluxDbConfigurationButton").disabled = true;

            var currentStatus = influxDbConfig ? influxDbConfig.lastConnectionStatus : "Unknown";
            var currentTimestamp = influxDbConfig ? influxDbConfig.lastConnectionAttemptTimestamp : "";

            var newInfluxDbConfig = {
                "enabled": document.getElementById("influxDbEnabled").checked,
                "server": document.getElementById("influxDbServer").value,
                "port": parseInt(document.getElementById("influxDbPort").value),
                "version": parseInt(document.getElementById("influxDbVersion").value),
                "database": document.getElementById("influxDbDatabase").value,
                "username": document.getElementById("influxDbUsername").value,
                "password": document.getElementById("influxDbPassword").value,
                "organization": document.getElementById("influxDbOrganization").value,
                "bucket": document.getElementById("influxDbBucket").value,
                "token": document.getElementById("influxDbToken").value,
                "measurement": document.getElementById("influxDbMeasurement").value,
                "frequency": Math.max(1, Math.min(3600, parseInt(document.getElementById("influxDbFrequency").value))),
                "useSsl": document.getElementById("influxDbUseSsl").checked,
                "lastConnectionStatus": currentStatus,
                "lastConnectionAttemptTimestamp": currentTimestamp
            };

            energyApi.setInfluxDbConfig(newInfluxDbConfig)
                .then(data => {
                    document.getElementById("setInfluxDbConfigurationButton").innerHTML = "Set success!";
                    setTimeout(() => {
                        getInfluxDbConfiguration(); // This will reload config and restart auto-reload if needed
                    }, 2000); // Wait 2 seconds for the device to process the new config
                    setTimeout(function () {
                        document.getElementById("setInfluxDbConfigurationButton").innerHTML = "Set configuration";
                        document.getElementById("setInfluxDbConfigurationButton").disabled = false;
                    }, 3000);
                })
                .catch(error => {
                    alert("Error setting InfluxDB configuration. Response: " + error.message);
                    document.getElementById("setInfluxDbConfigurationButton").innerHTML = "Set failed!";
                    setTimeout(function () {
                        document.getElementById("setInfluxDbConfigurationButton").innerHTML = "Set configuration";
                        document.getElementById("setInfluxDbConfigurationButton").disabled = false;
                    }, 3000);
                });

            // Call to refresh the InfluxDB configuration after setting it
            setTimeout(getInfluxDbConfiguration, 1000);
        }

        function loadChannelData() {
            return energyApi.getChannelConfig()
                .then(data => {
                    channelData = data;
                    createEnergyChannelInputs();
                    // Add a delay before loading energy values to prevent overwhelming ESP32
                    return new Promise(resolve => setTimeout(resolve, 300));
                })
                .then(() => {
                    return loadEnergyValues();
                })
                .catch(error => {
                    console.log("Error getting channel data. Response: " + error.message);
                    throw error; // Re-throw to handle in calling function
                });
        }

        function createEnergyChannelInputs() {
            const container = document.getElementById("energyChannels");
            container.innerHTML = "";

            for (let channelIndex in channelData) {
                const channel = channelData[channelIndex];
                if (channel.active) {
                    const channelDiv = document.createElement("div");
                    channelDiv.style.cssText = `
                        margin-bottom: 24px;
                        border: 1px solid #e1e5e9;
                        border-radius: 12px;
                        background: linear-gradient(145deg, #ffffff, #f8f9fa);
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08), 0 1px 3px rgba(0, 0, 0, 0.06);
                        padding: 20px;
                        transition: all 0.2s ease;
                    `;

                    // Add hover effect
                    channelDiv.addEventListener('mouseenter', function() {
                        this.style.transform = 'translateY(-2px)';
                        this.style.boxShadow = '0 4px 16px rgba(0, 0, 0, 0.12), 0 2px 6px rgba(0, 0, 0, 0.08)';
                    });
                    channelDiv.addEventListener('mouseleave', function() {
                        this.style.transform = 'translateY(0)';
                        this.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.08), 0 1px 3px rgba(0, 0, 0, 0.06)';
                    });

                    channelDiv.innerHTML = `
                        <div style="margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid #e9ecef;">
                            <h4 style="margin: 0; color: #2c3e50; font-size: 1.1em; font-weight: 600; display: flex; align-items: center;">
                                <span style="display: inline-block; width: 8px; height: 8px; background: linear-gradient(45deg, #007bff, #0056b3); border-radius: 50%; margin-right: 8px;"></span>
                                Channel ${channelIndex}: ${channel.label}
                            </h4>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 16px;">
                            <div style="display: flex; flex-direction: column;">
                                <label for="activeEnergyImported_${channelIndex}" style="color: #495057; font-weight: 500; margin-bottom: 6px; font-size: 0.9em;">
                                    <span style="color: #28a745;">‚ö°</span> Active Energy Imported (Wh)
                                </label>
                                <input type="number" step="0.001" id="activeEnergyImported_${channelIndex}" class="config-input" placeholder="0.000" 
                                       style="border: 1px solid #ced4da; border-radius: 6px; padding: 8px 12px; font-size: 0.9em; transition: all 0.2s ease;">
                            </div>
                            <div style="display: flex; flex-direction: column;">
                                <label for="activeEnergyExported_${channelIndex}" style="color: #495057; font-weight: 500; margin-bottom: 6px; font-size: 0.9em;">
                                    <span style="color: #ffc107;">‚ö°</span> Active Energy Exported (Wh)
                                </label>
                                <input type="number" step="0.001" id="activeEnergyExported_${channelIndex}" class="config-input" placeholder="0.000"
                                       style="border: 1px solid #ced4da; border-radius: 6px; padding: 8px 12px; font-size: 0.9em; transition: all 0.2s ease;">
                            </div>
                            <div style="display: flex; flex-direction: column;">
                                <label for="reactiveEnergyImported_${channelIndex}" style="color: #495057; font-weight: 500; margin-bottom: 6px; font-size: 0.9em;">
                                    <span style="color: #17a2b8;">üîÑ</span> Reactive Energy Imported (VArh)
                                </label>
                                <input type="number" step="0.001" id="reactiveEnergyImported_${channelIndex}" class="config-input" placeholder="0.000"
                                       style="border: 1px solid #ced4da; border-radius: 6px; padding: 8px 12px; font-size: 0.9em; transition: all 0.2s ease;">
                            </div>
                            <div style="display: flex; flex-direction: column;">
                                <label for="reactiveEnergyExported_${channelIndex}" style="color: #495057; font-weight: 500; margin-bottom: 6px; font-size: 0.9em;">
                                    <span style="color: #fd7e14;">üîÑ</span> Reactive Energy Exported (VArh)
                                </label>
                                <input type="number" step="0.001" id="reactiveEnergyExported_${channelIndex}" class="config-input" placeholder="0.000"
                                       style="border: 1px solid #ced4da; border-radius: 6px; padding: 8px 12px; font-size: 0.9em; transition: all 0.2s ease;">
                            </div>
                            <div style="display: flex; flex-direction: column;">
                                <label for="apparentEnergy_${channelIndex}" style="color: #495057; font-weight: 500; margin-bottom: 6px; font-size: 0.9em;">
                                    <span style="color: #6f42c1;">‚öôÔ∏è</span> Apparent Energy (VAh)
                                </label>
                                <input type="number" step="0.001" id="apparentEnergy_${channelIndex}" class="config-input" placeholder="0.000"
                                       style="border: 1px solid #ced4da; border-radius: 6px; padding: 8px 12px; font-size: 0.9em; transition: all 0.2s ease;">
                            </div>
                        </div>
                    `;

                    // Add focus effects to inputs
                    const inputs = channelDiv.querySelectorAll('input');
                    inputs.forEach(input => {
                        input.addEventListener('focus', function() {
                            this.style.borderColor = '#007bff';
                            this.style.boxShadow = '0 0 0 2px rgba(0, 123, 255, 0.25)';
                        });
                        input.addEventListener('blur', function() {
                            this.style.borderColor = '#ced4da';
                            this.style.boxShadow = 'none';
                        });
                    });

                    container.appendChild(channelDiv);
                }
            }
        }

        function loadEnergyValues() {
            document.getElementById("loadEnergyButton").innerHTML = "Loading...";
            document.getElementById("loadEnergyButton").disabled = true;

            return energyApi.getMeterValues()
                .then(data => {
                    energyData = data;

                    // Populate the form with current values
                    // API format: array of objects with index and data
                    energyData.forEach(channel => {
                        const channelIndex = channel.index;
                        const channelData = channel.data;

                        const activeImportedEl = document.getElementById(`activeEnergyImported_${channelIndex}`);
                        if (activeImportedEl) activeImportedEl.value = channelData.activeEnergyImported || 0;

                        const activeExportedEl = document.getElementById(`activeEnergyExported_${channelIndex}`);
                        if (activeExportedEl) activeExportedEl.value = channelData.activeEnergyExported || 0;

                        const reactiveImportedEl = document.getElementById(`reactiveEnergyImported_${channelIndex}`);
                        if (reactiveImportedEl) reactiveImportedEl.value = channelData.reactiveEnergyImported || 0;

                        const reactiveExportedEl = document.getElementById(`reactiveEnergyExported_${channelIndex}`);
                        if (reactiveExportedEl) reactiveExportedEl.value = channelData.reactiveEnergyExported || 0;

                        const apparentEl = document.getElementById(`apparentEnergy_${channelIndex}`);
                        if (apparentEl) apparentEl.value = channelData.apparentEnergy || 0;
                    });

                    document.getElementById("loadEnergyButton").innerHTML = "‚úì Values Loaded";
                })
                .catch(error => {
                    alert("Error loading energy values. Response: " + error.message);
                    document.getElementById("loadEnergyButton").innerHTML = "‚ùå Load Failed";
                })
                .finally(() => {
                    setTimeout(function () {
                        document.getElementById("loadEnergyButton").innerHTML = "üîÑ Load Current Values";
                        document.getElementById("loadEnergyButton").disabled = false;
                    }, 3000);
                });
        }

        function setEnergyValues() {
            var confirm = window.confirm("Are you sure you want to set these energy values? This will permanently erase all historical daily energy data.");
            if (!confirm) {
                return;
            }

            document.getElementById("setEnergyButton").innerHTML = "Setting...";
            document.getElementById("setEnergyButton").disabled = true;

            var energyPayload = {};

            // Collect values from all active channels
            for (let channelIndex in channelData) {
                const channel = channelData[channelIndex];
                if (channel.active) {
                    const activeImported = document.getElementById(`activeEnergyImported_${channelIndex}`);
                    const activeExported = document.getElementById(`activeEnergyExported_${channelIndex}`);
                    const reactiveImported = document.getElementById(`reactiveEnergyImported_${channelIndex}`);
                    const reactiveExported = document.getElementById(`reactiveEnergyExported_${channelIndex}`);
                    const apparent = document.getElementById(`apparentEnergy_${channelIndex}`);

                    if (activeImported && activeImported.value !== "") {
                        if (!energyPayload[channelIndex]) energyPayload[channelIndex] = {};
                        energyPayload[channelIndex].activeEnergyImported = parseFloat(activeImported.value);
                    }
                    if (activeExported && activeExported.value !== "") {
                        if (!energyPayload[channelIndex]) energyPayload[channelIndex] = {};
                        energyPayload[channelIndex].activeEnergyExported = parseFloat(activeExported.value);
                    }
                    if (reactiveImported && reactiveImported.value !== "") {
                        if (!energyPayload[channelIndex]) energyPayload[channelIndex] = {};
                        energyPayload[channelIndex].reactiveEnergyImported = parseFloat(reactiveImported.value);
                    }
                    if (reactiveExported && reactiveExported.value !== "") {
                        if (!energyPayload[channelIndex]) energyPayload[channelIndex] = {};
                        energyPayload[channelIndex].reactiveEnergyExported = parseFloat(reactiveExported.value);
                    }
                    if (apparent && apparent.value !== "") {
                        if (!energyPayload[channelIndex]) energyPayload[channelIndex] = {};
                        energyPayload[channelIndex].apparentEnergy = parseFloat(apparent.value);
                    }
                }
            }

            // Send all energy updates in parallel
            const updatePromises = [];
            for (let channelIndex in energyPayload) {
                const channel = energyPayload[channelIndex];
                updatePromises.push(
                    energyApi.setEnergyValues(
                        parseInt(channelIndex),
                        channel.activeEnergyImported || 0,
                        channel.reactiveEnergyImported || 0,
                        channel.apparentEnergy || 0
                    )
                );
            }

            Promise.all(updatePromises)
                .then(results => {
                    document.getElementById("setEnergyButton").innerHTML = "‚úì Values Set";
                })
                .catch(error => {
                    alert("Error setting energy values. Response: " + error.message);
                    document.getElementById("setEnergyButton").innerHTML = "‚ùå Set Failed";
                })
                .finally(() => {
                    setTimeout(function () {
                        document.getElementById("setEnergyButton").innerHTML = "Set Energy Values";
                        document.getElementById("setEnergyButton").disabled = false;
                    }, 3000);
                });
        }

        function resetAllEnergy() {
            var confirm = window.confirm("Are you sure you want to reset ALL energy values to zero? This will permanently erase all historical data.");
            if (!confirm) {
                return;
            }

            document.getElementById("resetAllEnergyButton").innerHTML = "Resetting...";
            document.getElementById("resetAllEnergyButton").disabled = true;

            energyApi.resetEnergyValues()
                .then(data => {
                    document.getElementById("resetAllEnergyButton").innerHTML = "‚úì Reset Complete";
                    // Clear all input fields
                    for (let channelIndex in channelData) {
                        const channel = channelData[channelIndex];
                        if (channel.active) {
                            const inputs = [
                                `activeEnergyImported_${channelIndex}`,
                                `activeEnergyExported_${channelIndex}`,
                                `reactiveEnergyImported_${channelIndex}`,
                                `reactiveEnergyExported_${channelIndex}`,
                                `apparentEnergy_${channelIndex}`
                            ];
                            inputs.forEach(id => {
                                const el = document.getElementById(id);
                                if (el) el.value = "0.000";
                            });
                        }
                    }
                })
                .catch(error => {
                    alert("Error resetting energy values. Response: " + error.message);
                    document.getElementById("resetAllEnergyButton").innerHTML = "‚ùå Reset Failed";
                })
                .finally(() => {
                    setTimeout(function () {
                        document.getElementById("resetAllEnergyButton").innerHTML = "Reset All to Zero";
                        document.getElementById("resetAllEnergyButton").disabled = false;
                    }, 3000);
                });
        }

        // Sequential API loading to prevent overwhelming the ESP32
        async function loadConfigurationData() {
            const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const DELAY_BETWEEN_REQUESTS = 100;
            
            try {
                console.log("Loading configuration data sequentially...");
                
                await getCloudServices();
                await delay(DELAY_BETWEEN_REQUESTS);
                
                await getLedBrightness();
                await delay(DELAY_BETWEEN_REQUESTS);
                
                await getLogLevel();
                await delay(DELAY_BETWEEN_REQUESTS);
                
                await getCustomMqttConfiguration();
                await delay(DELAY_BETWEEN_REQUESTS);
                
                await getInfluxDbConfiguration();
                await delay(DELAY_BETWEEN_REQUESTS);
                
                await checkHasSecrets();
                await delay(DELAY_BETWEEN_REQUESTS);
                
                await loadChannelData();
                
                console.log("Configuration data loaded successfully");
                
            } catch (error) {
                console.error("Error loading configuration data:", error);
                alert("Error loading configuration data. Please refresh the page.");
            }
        }

        // Cleanup function to stop all auto-reload intervals
        function stopAllAutoReload() {
            stopCustomMqttAutoReload();
            stopInfluxDbAutoReload();
        }

        // Stop auto-reload when page is unloaded
        window.addEventListener('beforeunload', stopAllAutoReload);

        document.addEventListener("DOMContentLoaded", function () {
            // Load configuration data sequentially to prevent ESP32 overload
            loadConfigurationData();

            // Add event listener for version change
            document.getElementById("influxDbVersion").addEventListener("change", toggleInfluxDbVersionSettings);
        });

    </script>

</body>

</html>