<!-- SPDX-License-Identifier: GPL-3.0-or-later -->
<!-- Copyright (C) 2025 Jibril Sharafi -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="/css/button.css">
    <link rel="stylesheet" type="text/css" href="/css/styles.css">
    <link rel="stylesheet" type="text/css" href="/css/section.css">
    <link rel="stylesheet" type="text/css" href="/css/typography.css">
    <link rel="stylesheet" type="text/css" href="/css/forms.css">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <title>Channel</title>
    <style>
        .channel-columns {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 10px;
            justify-items: center;
        }

        .channel-columns .section-box {
            width: 80%;
        }

        .channel-columns input[type="text"] {
            width: 90%;
            box-sizing: border-box;
        }
        
        /* Page-specific mobile styles */
        @media screen and (max-width: 768px) {
            .channel-columns {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 0 10px;
            }
            
            .channel-columns input[type="text"] {
                width: 100%;
            }
            
            .channel-item {
                width: 100%;
                padding: 15px;
                margin-bottom: 10px;
                border: 1px solid #eee;
                border-radius: 8px;
                background-color: #f9f9f9;
            }
            
            .channel-item h3 {
                font-size: 1.2rem;
                margin-bottom: 10px;
            }
            
            .power-display {
                font-size: 16px;
                font-weight: bold;
                color: #333;
                margin: 8px 0;
            }

            #updateStatus {
                font-size: 14px;
                margin: 10px 0;
            }
        }
        
        @media screen and (max-width: 480px) {
            .channel-columns {
                padding: 0 5px;
                gap: 12px;
            }
            
            .channel-item {
                padding: 12px;
            }
            
            .channel-item h3 {
                font-size: 1.1rem;
            }
            
            .channel-columns input[type="text"] {
                font-size: 14px;
                padding: 10px;
            }
            
            .channel-item label {
                font-size: 13px;
            }
            
            .power-display {
                font-size: 14px;
            }
            
            #updateStatus {
                font-size: 13px;
            }
        }
    </style>
</head>

<body>
    <div class="buttonNavigation-container">
        <a class="buttonNavigation" type="outer" href="/configuration">‚öôÔ∏è Configuration</a>
    </div>    <div id="channelContainer" class="section-box" style="text-align: center;">
        <h1>Channels</h1>
        <div class="channel-columns"></div>
    </div>
</body>

<script src="/js/api-client.js"></script>
<script>
    var channelData = {};
    var powerUpdateInterval = null;
    const FETCH_THROTTLE = 2000; // Increased for better stability
    var updateQueue = {};
    var isProcessingUpdate = false;

    // Initialize the page
    async function initializePage() {
        try {
            // Load channel config only
            const channelResponse = await energyApi.getChannelConfig();
            channelData = channelResponse;

            createChannelBoxes();
        } catch (error) {
            console.error('Error initializing page:', error);
            showStatus('Error loading data: ' + error.message, 'error');
        }
    }

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializePage);

    function createChannelBoxes() {
        const container = document.querySelector('.channel-columns');
        container.innerHTML = ''; // Clear existing content

        if (!channelData || Object.keys(channelData).length === 0) {
            container.innerHTML = '<p>No channel data available</p>';
            return;
        }

        Object.entries(channelData).forEach(([index, channel]) => {
            const box = document.createElement('div');
            box.className = 'section-box';
            box.style.textAlign = 'center';

            const phaseOptions = [
                { value: 1, label: '1' },
                { value: 2, label: '2' },
                { value: 3, label: '3' },
                { value: 4, label: '240V (Split Phase)' }
            ]
                .map(p => `<option value="${p.value}" ${p.value === channel.phase ? 'selected' : ''}>${p.label}</option>`)
                .join('');

            // Check if this is channel 0 (main voltage channel)
            const isChannel0 = index == 0;
            const activeCheckboxDisabled = isChannel0 ? 'disabled' : '';
            const activeChecked = isChannel0 ? 'checked' : (channel.active ? 'checked' : '');
            const highPriorityCheckboxDisabled = isChannel0 ? 'disabled' : '';
            const highPriorityChecked = isChannel0 ? 'checked' : (channel.highPriority ? 'checked' : '');

            box.innerHTML = `
                <h3>Channel ${index}</h3>
                <label>
                    Label:
                    <input type="text" value="${channel.label || ''}" id="label${index}" onchange="queueChannelUpdate(${index})">
                </label>
                <div style="height: 10px;"></div>
                <label>
                    Phase:
                    <select id="phase${index}" onchange="queueChannelUpdate(${index})">
                        ${phaseOptions}
                    </select>
                </label>
                <div style="height: 10px;"></div>
                <label>
                    <input type="checkbox" ${channel.reverse ? 'checked' : ''} id="reverse${index}" onchange="queueChannelUpdate(${index})">
                    Reverse
                </label>
                <div style="height: 10px;"></div>
                <label>
                    <input type="checkbox" ${activeChecked} id="active${index}" onchange="queueChannelUpdate(${index})" ${activeCheckboxDisabled}>
                    Active
                </label>
                <div style="height: 10px;"></div>
                <label>
                    <input type="checkbox" ${highPriorityChecked} id="highPriority${index}" onchange="queueChannelUpdate(${index})" ${highPriorityCheckboxDisabled}>
                    High Priority
                </label>
                <div style="height: 15px;"></div>
                <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                <h4 style="margin: 10px 0;">Grouping</h4>
                <label>
                    Group Label:
                    <input type="text" value="${channel.groupLabel || ''}" id="groupLabel${index}" onchange="queueChannelUpdate(${index})">
                </label>
                <div style="height: 15px;"></div>
                <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                <h4 style="margin: 10px 0;">Channel Role</h4>
                <label>
                    <select id="role${index}" onchange="queueChannelUpdate(${index})">
                        <option value="load" ${channel.role === 'load' ? 'selected' : ''}>Load</option>
                        <option value="grid" ${channel.role === 'grid' ? 'selected' : ''}>Grid (+ import, - export)</option>
                        <option value="pv" ${channel.role === 'pv' ? 'selected' : ''}>PV / Solar (+ generation)</option>
                        <option value="battery" ${channel.role === 'battery' ? 'selected' : ''}>Battery (+ discharge, - charge)</option>
                        <option value="inverter" ${channel.role === 'inverter' ? 'selected' : ''}>Inverter (PV + Battery DC-coupled)</option>
                    </select>
                </label>
                <div style="height: 10px;"></div>
                <span id="power${index}" style="font-weight: bold; color: #333;"></span>
                <div style="height: 15px;"></div>
                <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                <button class="buttonForm" onclick="resetChannelEnergy(${index})"
                    style="background-color: #dc3545; border-color: #dc3545; color: white; font-size: 0.85em; padding: 6px 12px;"
                    onmouseover="this.style.backgroundColor='#c82333'" onmouseout="this.style.backgroundColor='#dc3545'">
                    üóëÔ∏è Reset Energy
                </button>
            `;
            container.appendChild(box);

            if (channel.active) {
                startPowerUpdate(index);
            }
        });

        // Start global power updates if we have any active channels
        startGlobalPowerUpdates();
    }

    function startGlobalPowerUpdates() {
        // Stop any existing interval
        if (powerUpdateInterval) {
            clearInterval(powerUpdateInterval);
        }

        const updateAllPowerValues = async () => {
            try {
                const meterValuesArray = await energyApi.getMeterValues();
                
                // Update only active channels
                meterValuesArray.forEach(channelMeterData => {
                    const index = channelMeterData.index;
                    const powerElement = document.getElementById(`power${index}`);
                    
                    // Only show power if channel is active
                    if (powerElement && channelData[index] && channelData[index].active && 
                        channelMeterData.data && channelMeterData.data.activePower !== undefined) {
                        powerElement.innerHTML = `${channelMeterData.data.activePower.toFixed(1)} W`;
                    } else if (powerElement && channelData[index] && !channelData[index].active) {
                        // Clear power display for inactive channels
                        powerElement.innerHTML = '';
                    }
                });
                
            } catch (error) {
                console.error('Error fetching power values:', error);
                // Show error only on active channels
                Object.keys(channelData).forEach(index => {
                    if (channelData[index].active) {
                        const powerElement = document.getElementById(`power${index}`);
                        if (powerElement) {
                            powerElement.innerHTML = 'Error';
                        }
                    }
                });
            }
        };

        // Initial update
        updateAllPowerValues();
        
        // Set up interval for regular updates
        powerUpdateInterval = setInterval(updateAllPowerValues, FETCH_THROTTLE);
    }

    function stopGlobalPowerUpdates() {
        if (powerUpdateInterval) {
            clearInterval(powerUpdateInterval);
            powerUpdateInterval = null;
        }
    }

    function startPowerUpdate(index) {
        // Individual channel power updates are handled by the global update
        const powerElement = document.getElementById(`power${index}`);
        if (powerElement) {
            powerElement.innerHTML = 'Loading...';
        }
    }

    function stopPowerUpdate(index) {
        // Clear individual channel power display
        const powerElement = document.getElementById(`power${index}`);
        if (powerElement) {
            powerElement.innerHTML = '';
        }
    }

    function queueChannelUpdate(index) {
        // Prevent channel 0 from being disabled
        if (index == 0) {
            const activeCheckbox = document.getElementById(`active${index}`);
            if (activeCheckbox && !activeCheckbox.checked) {
                activeCheckbox.checked = true;
                showStatus('Channel 0 is the main voltage channel and cannot be disabled', 'error');
                return;
            }
        }

        // Detect role change BEFORE updating local data
        const oldData = channelData[index];
        const newRole = document.getElementById(`role${index}`).value;

        const roleChanged = oldData && (oldData.role !== newRole);

        if (roleChanged) {
            if (!confirm('Changing the channel role will reset its energy values and delete its historical data. This cannot be undone.\n\nDo you want to continue?')) {
                // Revert dropdown to original value
                document.getElementById(`role${index}`).value = oldData.role;
                return;
            }
        }

        doQueueChannelUpdate(index);
    }

    function doQueueChannelUpdate(index) {
        const channelUpdate = {
            index: parseInt(index),
            label: document.getElementById(`label${index}`).value,
            reverse: document.getElementById(`reverse${index}`).checked,
            phase: parseInt(document.getElementById(`phase${index}`).value),
            active: document.getElementById(`active${index}`).checked,
            highPriority: document.getElementById(`highPriority${index}`).checked,
            // Grouping
            groupLabel: document.getElementById(`groupLabel${index}`).value,
            // Channel role
            role: document.getElementById(`role${index}`).value,
        };

        // Update local channelData immediately for UI responsiveness
        if (channelData[index]) {
            channelData[index].active = channelUpdate.active;
            channelData[index].label = channelUpdate.label;
            channelData[index].reverse = channelUpdate.reverse;
            channelData[index].phase = channelUpdate.phase;
            channelData[index].highPriority = channelUpdate.highPriority;
            channelData[index].groupLabel = channelUpdate.groupLabel;
            channelData[index].role = channelUpdate.role;
        }

        // Store in queue - this will overwrite any previous update for this channel
        updateQueue[index] = channelUpdate;

        // Update UI responsiveness immediately
        if (channelUpdate.active) {
            startPowerUpdate(index);
        } else {
            stopPowerUpdate(index);
        }

        // Restart global power updates to include/exclude this channel
        startGlobalPowerUpdates();

        // Process updates after a short delay (debouncing)
        if (!isProcessingUpdate) {
            isProcessingUpdate = true;
            setTimeout(processChannelUpdates, 500);
        }
    }

    async function processChannelUpdates() {
        if (Object.keys(updateQueue).length === 0) {
            isProcessingUpdate = false;
            return;
        }

        try {
            showStatus('Updating channels...', '');

            // Send all queued updates using PATCH for partial updates
            const updates = Object.values(updateQueue);
            updateQueue = {}; // Clear queue

            for (const update of updates) {
                await energyApi.patchChannelConfig(update);
            }

            showStatus('Channels updated successfully', 'success');

        } catch (error) {
            console.error('Error updating channels:', error);

            if (error.message.includes('Channel 0 cannot be disabled')) {
                showStatus('Channel 0 cannot be disabled', 'error');
                // Reset channel 0 to active in UI
                const activeCheckbox = document.getElementById('active0');
                if (activeCheckbox) {
                    activeCheckbox.checked = true;
                }
            } else {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        isProcessingUpdate = false;

        // If there are new updates in queue, process them
        if (Object.keys(updateQueue).length > 0) {
            setTimeout(processChannelUpdates, 500);
        }
    }

    async function resetChannelEnergy(channelIndex) {
        const channel = channelData[channelIndex];
        const label = channel ? channel.label : `Channel ${channelIndex}`;

        if (!confirm(`Reset all energy values for "${label}" (Channel ${channelIndex}) to zero?\n\nThis will permanently delete all historical energy data for this channel.`)) {
            return;
        }

        try {
            await energyApi.resetEnergyValues(channelIndex);
            showStatus(`Energy values reset for ${label}`, 'success');
        } catch (error) {
            showStatus('Error resetting energy: ' + error.message, 'error');
        }
    }</script>

</html>