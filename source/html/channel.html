<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="/css/button.css">
    <link rel="stylesheet" type="text/css" href="/css/styles.css">
    <link rel="stylesheet" type="text/css" href="/css/section.css">
    <link rel="stylesheet" type="text/css" href="/css/typography.css">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="/html/auth.js"></script>

    <title>Channel</title>
    <style>
        .channel-columns {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 10px;
            justify-items: center;
        }

        .channel-columns input[type="text"] {
            width: 90%;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <div class="buttonNavigation-container">
        <a class="buttonNavigation" type="outer" href="/configuration">⚙️ Configuration</a>
    </div>    <div id="channelContainer" class="section-box" style="text-align: center;">
        <h1>Channels</h1>
        <div id="updateStatus" style="height: 20px; color: #666; font-style: italic;"></div>
        <div class="channel-columns"></div>
    </div>
</body>
<script>
    
    var channelData = {};
    var calibrationData = {};
    var intervals = {};
    var lastSetChannelTime = 0;
    const FETCH_THROTTLE = 1000;
    var pendingUpdates = {};
    var activeRequests = new Set();
    var updateQueue = [];
    var isProcessingQueue = false;

    function fetchData(endpoint) {
        if (activeRequests.has(endpoint)) {
            return Promise.reject('Request already in progress');
        }

        activeRequests.add(endpoint);
        return fetch(`/rest/${endpoint}`)
            .then(response => response.json())
            .finally(() => activeRequests.delete(endpoint));
    }

    Promise.all([fetchData('get-calibration'), fetchData('get-channel')])
        .then(([calibrationResponse, channelResponse]) => {
            calibrationData = calibrationResponse;
            channelData = channelResponse;
            createChannelBoxes();
        })
        .catch(error => console.error('Error:', error));

    function createChannelBoxes() {
        const container = document.querySelector('.channel-columns');
        container.innerHTML = ''; // Clear existing content

        Object.entries(channelData).forEach(([index, channel]) => {
            const box = document.createElement('div');
            box.className = 'section-box';
            box.style.textAlign = 'center';

            const calibrationOptions = Object.keys(calibrationData)
                .map(key => `<option value="${key}" ${key === channel.calibrationLabel ? 'selected' : ''}>${key}</option>`)
                .join('');

            const phaseOptions = [1, 2, 3]
                .map(phase => `<option value="${phase}" ${phase === channel.phase ? 'selected' : ''}>${phase}</option>`)
                .join('');

            // Check if this is channel 0 (main voltage channel)
            const isChannel0 = index == 0;
            const activeCheckboxDisabled = isChannel0 ? 'disabled' : '';
            const activeChecked = isChannel0 ? 'checked' : (channel.active ? 'checked' : '');

            box.innerHTML = `
                <label>
                    Label:
                    <input type="text" value="${channel.label}" id="label${index}" onchange="updateChannel(${index})">
                </label>
                <div style="height: 10px;"></div>
                <label>
                    Calibration:
                    <select id="calibration${index}" onchange="updateChannel(${index})">
                        ${calibrationOptions}
                    </select>
                </label>
                <div style="height: 10px;"></div>
                <label>
                    Phase:
                    <select id="phase${index}" onchange="updateChannel(${index})">
                        ${phaseOptions}
                    </select>
                </label>
                <div style="height: 10px;"></div>
                <label>
                    <input type="checkbox" ${channel.reverse ? 'checked' : ''} id="reverse${index}" onchange="updateChannel(${index})">
                    Reverse
                </label>
                <div style="height: 10px;"></div>
                <label>
                    <input type="checkbox" ${activeChecked} id="active${index}" onchange="updateChannel(${index})" ${activeCheckboxDisabled}>
                    Active ${isChannel0 ? '(Main voltage - cannot be disabled)' : ''}
                </label>
                <div style="height: 10px;"></div>
                <span id="power${index}"></span>
            `;
            container.appendChild(box);

            if (channel.active) {
                startPowerUpdate(index);
            }
        });
    }

    function startPowerUpdate(index) {
        if (intervals[index]) {
            clearInterval(intervals[index]);
        }

        const updatePower = () => {
            // Only fetch if no active request for this index
            if (!activeRequests.has(`active-power-${index}`)) {
                activeRequests.add(`active-power-${index}`);
                fetchData(`active-power?index=${index}`)
                    .then(dataActivePower => {
                        document.getElementById(`power${index}`).innerHTML = `${dataActivePower.value.toFixed(1)} W`;
                    })
                    .finally(() => {
                        activeRequests.delete(`active-power-${index}`);
                    });
            }
        };

        updatePower(); // Initial update
        intervals[index] = setInterval(updatePower, FETCH_THROTTLE);
    }

    function stopPowerUpdate(index) {
        if (intervals[index]) {
            clearInterval(intervals[index]);
            document.getElementById(`power${index}`).innerHTML = '';
            delete intervals[index];
        }
    }    function updateChannel(index) {
        // Prevent channel 0 from being disabled
        if (index == 0) {
            const activeCheckbox = document.getElementById(`active${index}`);
            if (activeCheckbox && !activeCheckbox.checked) {
                activeCheckbox.checked = true;
                alert('Channel 0 is the main voltage channel and cannot be disabled.');
                return;
            }
        }

        const channelUpdate = {
            index: index,
            label: document.getElementById(`label${index}`).value,
            calibrationLabel: document.getElementById(`calibration${index}`).value,
            reverse: document.getElementById(`reverse${index}`).checked,
            phase: parseInt(document.getElementById(`phase${index}`).value),
            active: document.getElementById(`active${index}`).checked,
            timestamp: Date.now()
        };

        // Add to queue
        updateQueue.push(channelUpdate);
        
        // Update active status for UI responsiveness
        if (channelUpdate.active) {
            startPowerUpdate(index);
        } else {
            stopPowerUpdate(index);
        }

        // Process queue if not already processing
        if (!isProcessingQueue) {
            processUpdateQueue();
        }
    }

    function processUpdateQueue() {
        if (updateQueue.length === 0 || isProcessingQueue) {
            return;
        }

        isProcessingQueue = true;

        // Get the most recent update for each channel
        const latestUpdates = {};
        updateQueue.forEach(update => {
            if (!latestUpdates[update.index] || latestUpdates[update.index].timestamp < update.timestamp) {
                latestUpdates[update.index] = update;
            }
        });

        // Clear the queue since we're processing all updates
        updateQueue = [];

        // Send the most recent update for each channel
        const channelsToUpdate = Object.keys(latestUpdates);
        if (channelsToUpdate.length > 0) {
            sendChannelUpdates(latestUpdates);
        } else {
            isProcessingQueue = false;
        }
    }    function sendChannelUpdates(latestUpdates) {
        const now = Date.now();
        
        // Show status
        document.getElementById('updateStatus').textContent = 'Updating channels...';
        
        // Check rate limiting
        if (now - lastSetChannelTime < FETCH_THROTTLE) {
            setTimeout(() => sendChannelUpdates(latestUpdates), FETCH_THROTTLE - (now - lastSetChannelTime));
            return;
        }

        if (activeRequests.has('set-channel')) {
            // If request is already active, retry after a delay
            setTimeout(() => sendChannelUpdates(latestUpdates), FETCH_THROTTLE);
            return;
        }

        lastSetChannelTime = now;
        activeRequests.add('set-channel');

        // Convert to the format expected by the backend
        const channelData = {};
        Object.values(latestUpdates).forEach(update => {
            channelData[update.index] = {
                label: update.label,
                calibrationLabel: update.calibrationLabel,
                reverse: update.reverse,
                phase: update.phase,
                active: update.active
            };
        });

        fetch('/rest/set-channel', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(channelData)
        })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || data.message || `HTTP ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('Success:', data);
                document.getElementById('updateStatus').textContent = 'Channels updated successfully';
                setTimeout(() => {
                    document.getElementById('updateStatus').textContent = '';
                }, 2000);
                
                // Mark processing as complete
                isProcessingQueue = false;
                
                // Process any new updates that came in while we were processing
                if (updateQueue.length > 0) {
                    setTimeout(processUpdateQueue, 100);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
                
                // Show user-friendly error message
                if (error.message.includes('Rate limited')) {
                    console.log('Request was rate limited, will retry...');
                    document.getElementById('updateStatus').textContent = 'Rate limited, retrying...';
                    // Retry after the suggested delay
                    setTimeout(() => sendChannelUpdates(latestUpdates), 1000);
                } else if (error.message.includes('Channel 0 cannot be disabled')) {
                    document.getElementById('updateStatus').textContent = 'Channel 0 cannot be disabled';
                    alert('Channel 0 is the main voltage channel and cannot be disabled.');
                    // Reset channel 0 to active in UI
                    const activeCheckbox = document.getElementById('active0');
                    if (activeCheckbox) {
                        activeCheckbox.checked = true;
                    }
                    isProcessingQueue = false;
                    setTimeout(() => {
                        document.getElementById('updateStatus').textContent = '';
                    }, 3000);
                } else {
                    document.getElementById('updateStatus').textContent = 'Error: ' + error.message;
                    alert('Error updating channel: ' + error.message);
                    isProcessingQueue = false;
                    setTimeout(() => {
                        document.getElementById('updateStatus').textContent = '';
                    }, 5000);
                }
                
                // Process any new updates that came in while we were processing
                if (updateQueue.length > 0) {
                    setTimeout(processUpdateQueue, 1000);
                }
            })
            .finally(() => {
                activeRequests.delete('set-channel');
            });
    }// Periodically process any queued updates
    setInterval(() => {
        if (updateQueue.length > 0 && !isProcessingQueue) {
            processUpdateQueue();
        }
    }, FETCH_THROTTLE);
</script>

</html>