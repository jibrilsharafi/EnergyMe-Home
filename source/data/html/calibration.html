<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="/css/button.css">
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="stylesheet" type="text/css" href="/css/section.css">
    <link rel="stylesheet" type="text/css" href="/css/typography.css">

    <link rel="icon" type="image/png" href="/images/favicon.png">

    <title>Calibration</title>
    <style>
        #meterTable {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
        }

        #meterTable th,
        #meterTable td {
            padding: 8px;
            border: 1px solid #ddd;
        }

        #meterTable th {
            font-weight: bold;
        }

        #meterTable td:first-child {
            border-right: 1px solid #ddd;
        }
    </style>
</head>

<body>
    <div class="buttonNavigation-container">
        <a class="buttonNavigation" type="outer" href="/configuration">Configuration</a>
    </div>
    <div id="calibrationBox" class="section-box">
        <h1>Calibration</h1>
        <form id="calibrationForm">
            <h3>Calibration</h3>
            <p><span class="list-key">Active Power - Gain - Channel A:</span> <input id="aWGain" name="ActivePowerGainChannelA" type="number" required></p>
            <p><span class="list-key">Active Power - Offset - Channel A:</span> <input id="aWattOs" name="ActivePowerOffsetChannelA" type="number" required></p>
            <p><span class="list-key">Reactive Power - Gain - Channel A:</span> <input id="aVarGain" name="ReactivePowerGainChannelA" type="number" required></p>
            <p><span class="list-key">Reactive Power - Offset - Channel A:</span> <input id="aVarOs" name="ReactivePowerOffsetChannelA" type="number" required></p>
            <p><span class="list-key">Apparent Power - Gain - Channel A:</span> <input id="aVaGain" name="ApparentPowerGainChannelA" type="number" required></p>
            <p><span class="list-key">Apparent Power - Offset - Channel A:</span> <input id="aVaOs" name="ApparentPowerOffsetChannelA" type="number" required></p>
            <p><span class="list-key">Current - Gain - Channel B:</span> <input id="bIGain" name="CurrentGainChannelB" type="number" required></p>
            <p><span class="list-key">Phase Calibration - Channel A:</span> <input id="phCalA" name="PhaseCalibrationChannelA" type="number" required></p>
            <p><span class="list-key">Phase Calibration - Channel B:</span> <input id="phCalB" name="PhaseCalibrationChannelB" type="number" required></p>
        </form>
        <div style="display: flex; justify-content: space-between;">
            <button class="buttonForm" type="submit" onclick="submitCalibrationData()" id="submitButton">Submit</button>
            <button class="buttonForm" onclick="repopulateFields()">Reload</button>
            <button class="buttonForm" type="default" onclick="resetDefaultCalibration()">Reset default calibration</button>
        </div>
    </div>

    <div id="meterBox" class="section-box">
        <h1>Live meter data</h1>
        <table id="meterTable">
            <tr>
                <th>Label</th>
                <th>Voltage</th>
                <th>Current</th>
                <th>Active power</th>
                <th>Apparent power</th>
                <th>Reactive power</th>
                <th>Power factor</th>
            </tr>
        </table>
    </div>

    <script>
        var meterData;
        var channelData;
        var calibrationData;

        function fetchData(endpoint) {
            return new Promise((resolve, reject) => {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    if (this.readyState == 4) {
                        if (this.status == 200) {
                            resolve(JSON.parse(this.responseText));
                        } else {
                            console.error(`Error fetching data from ${endpoint}. Status: ${this.status}`);
                            reject();
                        }
                    }
                };
                xhttp.open("GET", `/rest/${endpoint}`, true);
                xhttp.send();
            });
        }

        Promise.all([fetchData('meter')])
            .then(data => {
                meterData = data[0];
                showMeterDataInTable();
            })
            .catch(error => console.error('Error:', error));

        Promise.all([fetchData('meter'), fetchData('calibration'), fetchData('get-channel')])
            .then(data => {
                meterData = data[0];
                calibrationData = data[1];
                channelData = data[2];
                populateDropdown();
            })
            .catch(error => console.error('Error:', error));

        function populateDropdown() {
            var dropdown = document.getElementById('calibrationDropdown');
            calibrationData.forEach((data, index) => {
                var option = document.createElement('option');
                option.text = data.label;
                option.value = data.label;
                dropdown.add(option, index);
            });
            dropdown.selectedIndex = 0;
            fillCalibrationBox();
        }

        function fillCalibrationBox() {
            var selectedLabel = document.getElementById('calibrationDropdown').value;
            var matchingChannels = channelData.filter(channel => channel.calibration.aWGain === selectedLabel && channel.active);
            var errorElement = document.getElementById('dropdownError');

            if (matchingChannels.length === 0) {
                document.getElementById('currentVoltage').innerText = '';
                document.getElementById('currentCurrent').innerText = '';
                document.getElementById('currentActivePower').innerText = '';
                errorElement.innerText = 'No matching channels found for selected calibration.';
                errorElement.style.display = 'block';
                submitButton.style.display = 'none';
                return;
            }
            errorElement.style.display = 'none';
            var currentData = meterData.find(data => data.label === matchingChannels[0].label);
            if (currentData) {
                document.getElementById('currentVoltage').innerText = currentData.data.voltage.toFixed(1);
                document.getElementById('currentCurrent').innerText = currentData.data.current.toFixed(3);
                document.getElementById('currentActivePower').innerText = currentData.data.activePower.toFixed(1);
                document.getElementById('expectedVoltage').value = currentData.data.voltage.toFixed(1);
                document.getElementById('expectedCurrent').value = currentData.data.current.toFixed(3);
                document.getElementById('expectedActivePower').value = currentData.data.activePower.toFixed(1);
                submitButton.style.display = 'block';
            } else {
                console.error('No matching meter data found for label:', matchingChannels[0].label);
                submitButton.style.display = 'none';
            }
        }

        function submitCalibrationData() {
            var selectedLabel = document.getElementById('calibrationDropdown').value;
            var matchingChannel = channelData.find(channel => channel.calibration.aWGain === selectedLabel);
            var currentMeterData = meterData.find(data => data.label === matchingChannel.label);
            var currentCalibrationData = calibrationData.find(data => data.label === selectedLabel);
            var expectedVoltage = document.getElementById('expectedVoltage').value;
            var expectedCurrent = document.getElementById('expectedCurrent').value;
            var expectedActivePower = document.getElementById('expectedActivePower').value;
            var noLoadChecked = document.getElementById('noLoadCheckbox').checked;

            var newVoltageSlope = currentCalibrationData.values.voltage.slope;
            var newCurrentSlope = currentCalibrationData.values.current.slope;
            var newActivePowerSlope = currentCalibrationData.values.activePower.slope;

            var newCurrentIntercept = currentCalibrationData.values.current.intercept;
            var newActivePowerIntercept = currentCalibrationData.values.activePower.intercept;

            newVoltageSlope = currentMeterData.data.voltage != 0
                    ? currentCalibrationData.values.voltage.slope * expectedVoltage / currentMeterData.data.voltage
                    : currentCalibrationData.values.voltage.slope;

            if (!noLoadChecked) {
                newCurrentSlope = currentMeterData.data.current != 0
                    ? currentCalibrationData.values.current.slope * expectedCurrent / currentMeterData.data.current
                    : currentCalibrationData.values.current.slope;
                newActivePowerSlope = currentMeterData.data.activePower != 0
                    ? currentCalibrationData.values.activePower.slope * expectedActivePower / currentMeterData.data.activePower
                    : currentCalibrationData.values.activePower.slope;
            } else {
                newCurrentIntercept = newCurrentIntercept - currentMeterData.data.current;
                newActivePowerIntercept = newActivePowerIntercept - currentMeterData.data.activePower;
            }

            var newCalibrationData = {
                label: currentCalibrationData.label,
                values: {
                    voltage: {
                        slope: newVoltageSlope
                    },
                    current: {
                        slope: newCurrentSlope,
                        intercept: newCurrentIntercept
                    },
                    activePower: {
                        slope: newActivePowerSlope,
                        intercept: newActivePowerIntercept
                    }
                }
            };

            var existingIndex = calibrationData.findIndex(data => data.label === selectedLabel);
            if (existingIndex !== -1) {
                calibrationData[existingIndex] = newCalibrationData;
            } else {
                calibrationData.push(newCalibrationData);
            }

            var xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function () {
                if (this.readyState == 4 && this.status == 200) {
                    alert("Calibration data submitted successfully");
                    location.reload();
                }
            };
            xhttp.open("POST", "/rest/calibration", true);
            xhttp.send(JSON.stringify(calibrationData));
        }

        function addAnotherCalibration(event) {
            event.preventDefault();
            var dropdown = document.getElementById('calibrationDropdown');
            var newLabel = prompt("Enter a label for the new calibration:");
            if (newLabel === null || newLabel === "") {
                return;
            }
            var newData = {
                label: newLabel,
                values: {
                    voltage: {
                        slope: calibrationData[0].values.voltage.slope
                    },
                    current: {
                        slope: calibrationData[0].values.current.slope,
                        intercept: calibrationData[0].values.current.intercept
                    },
                    activePower: {
                        slope: calibrationData[0].values.activePower.slope,
                        intercept: calibrationData[0].values.activePower.intercept
                    }
                }
            };
            calibrationData.push(newData);
            var newOption = document.createElement('option');
            newOption.text = newLabel;
            newOption.value = newLabel;
            dropdown.add(newOption);
            dropdown.selectedIndex = dropdown.options.length - 1;
            
            var xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function () {
                if (this.readyState == 4) {
                    if (this.status == 200) {
                        alert("Calibration data submitted successfully. You will be redirected to the channel page, where you can assign the new calibration to a channel. Then, you can come back to this page to calibrate the new configuration.");
                        window.location.href = "/channel";
                    } else {
                        console.error("Error submitting calibration data");
                    }
                }
            };
            xhttp.open("POST", "/rest/calibration", true);
            xhttp.send(JSON.stringify(calibrationData));
        }

        function repopulateFields() {
            Promise.all([fetchData('meter')])
                .then(data => {
                    meterData = data[0];
                    showMeterDataInTable();
                    fillCalibrationBox();
                })
                .catch(error => console.error('Error:', error));
        }

        function showMeterDataInTable() {
            var table = document.getElementById("meterTable");
            table.innerHTML = "<tr><th>Label</th><th>Voltage</th><th>Current</th><th>Active power</th><th>Apparent power</th><th>Reactive power</th><th>Power factor</th></tr>";

            meterData.forEach(function (meter) {
                var row = table.insertRow();
                var labelCell = row.insertCell(0);
                var voltageCell = row.insertCell(1);
                var currentCell = row.insertCell(2);
                var activePowerCell = row.insertCell(3);
                var apparentPowerCell = row.insertCell(4);
                var reactivePowerCell = row.insertCell(5);
                var powerFactorCell = row.insertCell(6);

                labelCell.innerHTML = meter.label;
                voltageCell.innerHTML = meter.data.voltage.toFixed(1) + " V";
                currentCell.innerHTML = meter.data.current.toFixed(3) + " A";
                activePowerCell.innerHTML = meter.data.activePower.toFixed(1) + " W";
                apparentPowerCell.innerHTML = meter.data.apparentPower.toFixed(1) + " VA";
                reactivePowerCell.innerHTML = meter.data.reactivePower.toFixed(1) + " VAr";
                powerFactorCell.innerHTML = (meter.data.powerFactor * 100.0).toFixed(1) + " %";
            });
        }

        function resetDefaultCalibration() {
            var r = confirm("Are you sure you want to reset the calibration to the default values?");
            if (r == true) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    if (this.readyState == 4) {
                        if (this.status == 200) {
                            alert("Default calibration reset successfully");
                            location.reload();
                        } else {
                            console.error("Error submitting default calibration data");
                        }
                    }
                };
                xhttp.open("POST", "/rest/calibration/reset", true);
                xhttp.send();
            }
        }

        document.getElementById("calibrationDropdown").addEventListener("change", function () {
            fillCalibrationBox();
        });

        document.getElementById('calibrationForm').addEventListener('submit', function (event) {
            event.preventDefault();
            submitCalibrationData();
        });

    </script>
</body>

</html>